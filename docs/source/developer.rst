.. role:: py:class(xref)
.. role:: py:meth(xref)
.. role:: py:func(xref)
.. role:: py:attr(xref)
.. role:: py:mod(xref)

Developer Docs
==============

Profiling Model
---------------

To profile a JAX model, you can use the :py:mod:`jax.profiler` module. The following code snippet shows how to start a trace, run your model, and then stop the trace. This will generate a trace file in the specified directory, which can be visualized using tools like TensorBoard or Perfetto.

For more information about JAX profiling, refer to the official documentation: `https://docs.jax.dev/en/latest/profiling.html`_

.. _`https://docs.jax.dev/en/latest/profiling.html`: https://docs.jax.dev/en/latest/profiling.html

.. code-block:: python

   import jax.profiler

   # Start a trace and create a Perfetto trace file
   jax.profiler.start_trace("./tensorboard_logs", create_perfetto_trace=True)

   model = Model(
       # geometry=realistic_geometry,
   )

   # Run the model
   predictions = model.run(
       save_interval=.5/24,
       total_time=1/24,
       # forcing=realistic_forcing,
   )

   # Ensure all computations are complete before stopping the trace
   jax.tree_util.tree_map(
       lambda x: x.block_until_ready() if hasattr(x, 'block_until_ready') else x,
       predictions
   )

   # Stop the trace
   jax.profiler.stop_trace()

You can visualize the generated trace file using **Perfetto**, a performance analysis tool for a variety of platforms.
To use Perfetto, navigate to https://ui.perfetto.dev/ in your web browser. Then, click "Open trace file" and select the
`.perfetto-trace` file generated by :py:func:`jax.profiler.start_trace`. This will display a detailed timeline of your
model's execution, showing CPU and GPU activity, memory usage, and other performance metrics, which is useful for debugging performance bottlenecks.

Multi-Device Parallelization
-----------------------------

JCM supports multi-device parallelization using JAX's SPMD (Single Program Multiple Data) sharding. This allows you to split computation across multiple GPUs or TPUs for faster execution, especially useful for higher resolution simulations.

Basic Concepts
^^^^^^^^^^^^^^

**SPMD Mesh**: Defines how to partition data across devices. The mesh has three dimensions corresponding to ``(x, y, z)`` or ``(longitude, latitude, vertical)``.

**FastSphericalHarmonics**: An optimized spherical harmonics implementation that works efficiently with sharded arrays. Use this when enabling SPMD sharding.

**Sharding Strategy**: Typically, you want to shard the longitude dimension first since it usually has the most grid points.

Enabling Parallelization
^^^^^^^^^^^^^^^^^^^^^^^^

To enable multi-device parallelization, pass ``spmd_mesh`` and ``use_fast_harmonics=True`` when creating your geometry:

.. code-block:: python

   import jax
   from jcm.model import Model
   from jcm.geometry import Geometry

   # Check available devices
   print(f"Available devices: {jax.devices()}")
   print(f"Number of devices: {len(jax.devices())}")

   # Create a mesh to split longitude across 4 devices
   # Mesh shape (4, 1, 1) means:
   #   - Split longitude dimension across 4 devices
   #   - Don't split latitude (1)
   #   - Don't split vertical (1)
   mesh = jax.make_mesh((4, 1, 1), ('x', 'y', 'z'))

   # Create geometry with sharding enabled
   geometry = Geometry.from_spectral_truncation(
       spectral_truncation=85,  # Higher resolution benefits from parallelization
       num_levels=8,
       spmd_mesh=mesh,
       use_fast_harmonics=True  # Necessary when using spmd_mesh
   )

   # Create and run model as usual
   model = Model(geometry=geometry, time_step=30.0)
   predictions = model.run(save_interval=5.0, total_time=30.0)

Mesh Configuration Guidelines
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The product of mesh dimensions must equal the number of available devices:

- ``(4, 1, 1)``: Split longitude across 4 devices
- ``(2, 2, 1)``: Split longitude (2) and latitude (2) across 4 devices total
- ``(8, 1, 1)``: Split longitude across 8 devices (for higher resolutions)

**Rules of thumb:**

1. Product of mesh dimensions = number of devices
2. Longitude (x) usually has most grid points → split first
3. Always use ``use_fast_harmonics=True`` when ``spmd_mesh`` is provided
4. Higher resolutions (T85+) benefit more from sharding
5. Match mesh to your device count: 4 GPUs → mesh product should equal 4

Using with Terrain Files
^^^^^^^^^^^^^^^^^^^^^^^^^

You can also enable sharding when loading realistic terrain:

.. code-block:: python

   from jcm.forcing import ForcingData

   mesh = jax.make_mesh((4, 1, 1), ('x', 'y', 'z'))

   geometry = Geometry.from_terrain_file(
       terrain_file='jcm/data/bc/terrain_t85.nc',
       spmd_mesh=mesh,
       use_fast_harmonics=True
   )

   forcing = ForcingData.from_file('jcm/data/bc/forcing_daily_t85.nc')

   model = Model(geometry=geometry, time_step=30.0)
   predictions = model.run(
       save_interval=5.0,
       total_time=30.0,
       forcing=forcing
   )

Single Device (Default Behavior)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you don't specify ``spmd_mesh``, JCM runs on a single device using the default ``RealSphericalHarmonics`` implementation:

.. code-block:: python

   # No sharding - runs on single device
   geometry = Geometry.from_spectral_truncation(
       spectral_truncation=31,
       num_levels=8
   )

This is the recommended approach for smaller resolutions (T31, T42) or when you only have a single GPU/TPU available.